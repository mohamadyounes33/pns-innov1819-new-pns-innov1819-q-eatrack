"""
    This program creates recommendations of recipes for a group of users
    It used the csv file of recommendations that exists in Res/ and was generated by the recommendation system
    to predict the top n recipes for each users.

    This program uses the result of individual recommendations to recommend recipes to a group of users.
    It uses a technique called aggregated voting that has the task is to determine the set of items that increase
    the overall individual satisfaction scores of all the users in the group.

    The objective is to maximise the overall satisfaction of the group.

    The type of aggregated voting used is additive utilitarian which is a strategy where individual ratings are summed
    for each item. It is also known as an average strategy because resulting group ranking gives the same result as
    taking the average of individual ratings.

    The program also filters recommended recipes based on preferences of each users and what they dislike if they have
    allergy toward a specific ingredient.

    if a user has a preference for an ingredient and a recipe contains that ingredient then the score of vote of that
    user will increase by 1. For example if the predicted rate of a recipe was 4 by a certain user and that recipe
    contains an ingredient preferred by that user, then its vote will become 5 for that recipe.

    if a user has an allergy toward an ingredient, and there was a recipe was in his top n list of recommended recipes
    or of another user in the group, then the recipe will be removed from recommended recipes for that group of users.


"""
import ast
import sys

from src.client_side.profiles_service_requester import get_group_profils, get_profil

sys.path.append("..")
from src.preferences_rec import *
from utils.tools import *


import os



# static list
recipe_note_list = []


# read clean recipes data base
path = os.path.dirname(os.path.realpath(__file__))
recipes = pd.read_csv(path+"/../Res/clean_recipes.csv", sep=";")
recommendations = pd.read_csv(path+"/../Res/recommendations.csv", sep=",")


# get a recipes by id
# parameters : recipe's id
def recipe_from_id(recipe_ids):
    """
    This function retrieves the data frame of recipes using their ids
    :param recipe_ids: a list of recipes id
    :return: a data frame of recipes
    """
    df = pd.DataFrame()
    for recipe_id in recipe_ids:
        df2 = recipes[recipes["RecipeID"] == int(recipe_id)][
            ["RecipeID", "Recipe Name", "Ingredients", "Recipe Photo", "Review Count", "Prepare Time", "Cook Time",
             "Total Time",
             "Directions"]]
        df = df.append(df2, ignore_index=True)
    return df


def get_all_recommendations(csv_file):
    """
    This function reads all recommendations for users using the result of the recommendation system stored in a csv file
    :param csv_file: the csv file where the recommendations are stored
    :return: the dataframe of recommendations predicted for users
    """
    df_recommendations = csv_file
    df_recommendations.columns = ['user_id', 'recommendations']
    return df_recommendations


def get_group_recommendations(users, recommendations):
    """function to get the history of recommendations done to a group of users

    :param users: list of ids of users
    :param recommendations: dataframe of recommendations for all users
    :return: data frame of recommendation for the specific group of users
    """
    group_ids = [i.get_user_id() for i in users]
    group_recommendations = recommendations[recommendations["user_id"].isin(group_ids)]
    return group_recommendations


def union_recommendations(recommendations):
    """
    function to get a union of recommended recipes, it deletes duplicated recommended recipes
    :param recommendations: list of recommendations
    :return: list of recommendation for all users without duplication
    """
    global recipe_note_list
    L = []
    for recommendation in recommendations['recommendations']:
        map_recipe_note = {}
        if recommendation not in L:

            # formating elements because they are strings
            split1 = recommendation.split('[')
            split1.pop(0)
            string_from_split1 = split1[0]
            string_from_split1 = string_from_split1[:-1]
            string_from_split1 = string_from_split1.replace(')', '')
            string_from_split1 = string_from_split1.replace('(', '')

            list_split_by_come = string_from_split1.split(',')
            final_list = []
            for i in range(0, len(list_split_by_come) - 1, 2):
                elem = list_split_by_come[i].replace(' ', '')

                value = (float)(list_split_by_come[i + 1].replace(' ', ''))
                value = "%.2f" % value
                map_recipe_note[elem] = (float)(value)

                final_list.append(elem)
                L.append(elem)

        recipe_note_list.append(map_recipe_note)

    # removing duplicates
    L = list(dict.fromkeys(L))

    return L


def filter_fridge(recipes, fridge):
    """
    This function removes recipes that doesn't contains ingredients available in the fridge.
    :param recipes: a data frame of recipes to filter
    :param fridge: the list of ingredients from the user's fridge
    :return: data frame of recipes containing at least an ingredient from the fridge
    """
    fridge_str = "|".join(fridge)
    possible_recipes = recipes[recipes["Ingredients"].str.contains(fridge_str)]
    return recipes[recipes["RecipeID"].isin(possible_recipes["RecipeID"])]

def get_line_vote(group_users, recommendations):
    """
    function to get for a user his ratings for every recipes, 0 for non tested recipes
    +1 to the vote if the recipe contains a preferred ingredient the user
    :param group_users: a group of users ids
    :param recommendations: the set (union) of recommended recipes for this group
    :return: the row (list) of votes of a user for all recipes recommended to the group
    """
    row_list = []

    for i in range(0, len(group_users)):
        user_list = []
        user_list.append(group_users[i].get_user_id())
        preferences = personal_preference(group_users[i])
        for recipe in union_recommendations(recommendations):
            # score to privilege recipes that contains preferred ingredients
            score_pref = contains_ingredient_nbr(recipe, preferences)
            if recipe not in recipe_note_list[i].keys():
                user_list.append(0 + score_pref)
            else:
                user_list.append(recipe_note_list[i][recipe] + score_pref)

        row_list.append(user_list)
    return row_list


def get_line_vote_fridge(group_users, recommendations, fridge):
    """
    function to get for a user his ratings for every recipes, 0 for non tested recipes
    +1 to the vote if the recipe contains a preferred ingredient the user
    as well as privileging recipes that maximise the usage of the fridge for family:
    +5 to the vote if the recipe contains an ingredient in the fridge
    :param fridge: a list of ingredients that the user has in its fridge
    :param group_users: a group of users ids
    :param recommendations: the set (union) of recommended recipes for this group
    :return: the row (list) of votes of a user for all recipes recommended to the group
    """
    row_list = []

    for i in range(0, len(group_users)):
        user_list = []
        user_list.append(group_users[i].get_user_id())
        preferences = personal_preference(group_users[i])
        for recipe in union_recommendations(recommendations):
            # score to privilege recipes that contains preferred ingredients
            score_pref = contains_ingredient_nbr(recipe, preferences)
            # score to privilege recipes that contains ingredients from the user's fridge
            score_fridge = 5 * contains_ingredient_nbr(recipe, fridge)
            if recipe not in recipe_note_list[i].keys():
                user_list.append(0 + score_pref + score_fridge)
            else:
                user_list.append(recipe_note_list[i][recipe] + score_pref + score_fridge)
        row_list.append(user_list)
    return row_list


def get_pandas_df(listtte, union_recipes):
    """
    function to transform a list to a pandas data frame
    :param listtte: list of lists , every list contains user id and ratings
    :param union_recipes: the set (union) of recommended recipes for this group
    :return: data frame that contains votes of all users for all recommended recipes to the group
    """
    entete = []
    entete.append("user_id")
    entete = entete + union_recipes
    df = pd.DataFrame(data=listtte, columns=entete)
    return df


def aggregated_voting(users_list, Fridge=False):
    """
    Function to create aggregated voting matrix.
    It creates the data frame with users in column and recipes in rows,
    adds the sum for every column, then sort the recipes based on that sum
    removes recipes that have ingredients disliked by a member of the group
    :param users_list: list of users ids
    :return: the list of filtered recipes recommended to the group and sorted by votes of all users
    """
    fridge = []
    group_users = idToUser(users_list)
    if Fridge:
        # TODO call other service, this is just a test without using the service. to delete later
        # group_users[0].add_ingredients_fridge(["chocolate", "banana", "eggs"])
        # get the list of ingredients contained in the fridge using connection with the users' server
        if len(users_list) > 1:
            fridge = ast.literal_eval(get_group_profils(users_list))['fridge']
        else:
            fridge = ast.literal_eval(get_profil(users_list[0]))['fridge']
    all_rec = get_all_recommendations(recommendations)

    group_rec = get_group_recommendations(group_users, all_rec)
    dislikes = union_group_undesirable(group_users)
    union_rec = union_recommendations(group_rec)
    if not Fridge:
        all_df_rows = get_line_vote(group_users, group_rec)
    else:
        all_df_rows = get_line_vote_fridge(group_users, group_rec, fridge)
    df = get_pandas_df(all_df_rows, union_rec)
    df.loc['s'] = df.sum()
    df = df.sort_values(by='s', axis=1, ascending=False)
    print(df)
    recommended_sorted = df.columns[1:].values
    test = recipe_from_id(recommended_sorted)
    # if recommendation should consider only the fridge
    # if fridge:
    #    test = filter_fridge(test, fridge)
    # if there are people in the group who have dislikes or allergies, remove recipes that contains those ingredients
    if dislikes:
        test = remove_dislikes(test, dislikes)
    #print(test["Ingredients"].values)
    res = list(test.T.to_dict().values())
    return res


if __name__ == "__main__":
    print(aggregated_voting([675719, 2810501], True))
    print(aggregated_voting([675719], True))
    #print("main")
